/***********************************************************************************************
 *
 *  Macro Bridge3D3SpanSpandrels
 *
 *  Automated generation of the spandrel walls in the full 3D model of the 3 span bridge segment
 *  
 *  (Wall discretisation conformant to elastic ballast layer atop of the backfill)
 *
 ***********************************************************************************************/
// MESH A SPANDREL WALL ON EACH CALL OF THIS MACRO, VIA Y-EXTRUSION(S)

// NOTES:	* XZ GEOMETRY AND LOADS DEFINED IN ANOTHER MACRO (Bridge2D3Span) WITH THE
//		  EXCEPTION OF THE PARAPET, DEFINED IN Bridge3D3Span
//		* ALL INPUT PARAMETERS NEEDED HERE ARE CARRIED ALONG FROM  PREVIOUS MACROS 

Macro Bridge3D3SpanSpandrels

/*
IN:    		[WSp        = Width of the spandrel wall]
       		[NLSp       = Number of layers along WSp (in Y) upon discretisation]
       		[HPp        = Height of the parapet, measured from the top of the backfill]
       		[NLPp       = Number of layers along HPp (in Z) upon discretisation]
	
		+ other args carried along from previous macros

INOUT:		S_Yext[]   = List of ALL Surfaces at Y=WSp
		S_abtbk[]  = List of Surfaces at the backing 'abutments'
		S_base[]   = List of Surfaces at the pier bases
		S_abtarc[] = List of Surfaces at the arch 'abutments'
		S_abtbf[]  = List of Surfaces at the backfill 'abutments'
		S_abtpp[]  = List of Surfaces at the parapet 'abutments'

		V_BK[]     = List of Volumes forming the backings
		V_PR[]	   = List of Volumes forming the piers
		V_SK[]	   = List of ALL Volumes forming the skewbacks
		V_SK20[]   = List of WEDGE Volumes forming the skewbacks
		V_SK15[]   = List of HEXAHEDRAL Volumes forming the skewbacks
		V_AR[]	   = List of Volumes forming forming the arches
		V_BF[]	   = List of Volumes forming the backfill
		V_PP[]	   = List of Volumes forming the parapet

		S_SK[]     = List with Surfaces forming the skewbacks (2D)]
		S_PR[]     = List with Surfaces forming the piers (2D)]
		S_AR[]     = List with Surfaces forming the arches (2D)]
		S_BK[]     = List with Surfaces forming the backing 'area' (2D)]
		S_BF[]     = List with Surfaces forming the backfill 'area' (2D)]

OUT: 		extBK[]	   = List with all entities arising from extrusion of backings
		extPR[]	   = List with all entities arising from extrusion of piers
		extSK[]	   = List with all entities arising from extrusion of skewbacks
		extAR[]	   = List with all entities arising from extrusion of arches
		extBF[]	   = List with all entities arising from extrusion of backfill
		extPP1[]   = List with all entities arising from 1st extrusion for parapet
		extPP2[]   = List with all entities arising from 2nd extrusion for parapet
		S_PP[]	   = List of Surfaces forming the top of the backfill 'area'
	
		+ output from embedded macros
*/
//------------------------------------------------------------------------------
// EXTRUSIONS OF DIFFERENT BRIDGE 'AREAS' ALONG WSp IN SUCCESSIVE STAGES:
// (RECALL ALL OF THESE EXTRUDED 'AREAS' PERTAIN TO THE SPANDREL WALL)
//------------------------------------------------------------------------------
// [1] BACKING 'AREA'
extBK[] = Extrude {0,WSp,0} { Surface{S_BK[]}; Layers{NLSp}; Recombine; };

// STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST AND 
// UPDATE Surface LIST AT Y=prev.width+WSp
Call SurfaceVolumeRetrievalBacking;

// UPDATE S_BK[] FOR FUTURE Y-EXTRUSIONS
S_BK[] = {S_Yext[]};
//------------------------------------------------------------------------------
// [2] PIERS
extPR[] = Extrude {0,WSp,0} { Surface{S_PR[]}; Layers{NLSp}; Recombine; };

// STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
V_PR[] = {V_PR[], extPR[{1:#extPR[]-1:6}]};

// UPDATE Surface LIST AT Y=prev.width+WSp
S_Yext[] = {S_Yext[], extPR[{0:#extPR[]-1:6}]};

// UPDATE Surface LIST AT THE BASE OF THE PIERS
S_base[] = {S_base[], extPR[{4:#extPR[]-1:6}]};

// UPDATE S_PR[] FOR FUTURE Y-EXTRUSIONS
S_PR[] = { extPR[{0:#extPR[]-1:6}] };
//------------------------------------------------------------------------------
// [3] SKEWBACKS
extSK[] = Extrude {0,WSp,0} { Surface{S_SK[]}; Layers{NLSp}; Recombine; };

// STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST AND
// UPDATE Surface LIST AT Y=prev.width+WSp
Call SurfaceVolumeRetrievalSkewback;

// UPDATE S_SK[] FOR FUTURE Y-EXTRUSIONS
S_SK[] = { S_Yext[{#S_Yext[]-(aux1*4+aux2sk*2) : #S_Yext[]-1}] };
//------------------------------------------------------------------------------
// [4] ARCHES
extAR[] = Extrude {0,WSp,0} { Surface{S_AR[]}; Layers{NLSp}; Recombine; };

// STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
V_AR[] = {V_AR[], extAR[{1:#extAR[]-1:6}]};

// UPDATE Surface LIST AT Y=prev.width+WSp
S_Yext[] = {S_Yext[], extAR[{0:#extAR[]-1:6}]};

// UPDATE Surface LIST AT THE ARCH 'ABUTMENTS'
auxabtarc = 4+6*(TL1-1)*((TL3-2)+(TL4-1)+(TL3-1));
S_abtarc[] = {S_abtarc[], extAR[{ auxabtarc : auxabtarc+6*(TL1-2) : 6 }]};
auxabtarc2 = 3*auxabtarc+2*6*(TL1-2)+2*2;
S_abtarc[] = {S_abtarc[], extAR[{ auxabtarc2 : auxabtarc2+6*(TL1-2) : 6}]};

// UPDATE S_AR[] FOR FUTURE Y-EXTRUSIONS
S_AR[] = { extAR[{0:#extAR[]-1:6}] };
//------------------------------------------------------------------------------
// [5] BACKFILL 'AREA'
extBF[] = Extrude {0,WSp,0} { Surface{S_BF[]}; Layers{NLSp}; Recombine; };

// STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
V_BF[] = {V_BF[], extBF[1]};

// UPDATE Surface LIST AT Y=prev.width+WSp
S_Yext[] = {S_Yext[], extBF[0]};

// UPDATE Surface LIST AT THE BACKFILL 'ABUTMENTS'
S_abtbf[] = {S_abtbf[], extBF[#extBF[]-1]};
S_abtbf[] = { S_abtbf[], extBF[2+#Lbf[]] };

// UPDATE S_BF[] FOR FUTURE Y-EXTRUSIONS
S_BF[] = {extBF[0]};
//------------------------------------------------------------------------------
// [6] UPWARDS EXTRUSION FROM THE TOP OF THE 'BACKFILL VOLUME' TO GENERATE
//     THE PARAPET
S_PP[] = extBF[{2:1+#Lbf[]}];

// 1st EXTRUSION CONFORMANT TO ELASTIC LAYER ATOP OF THE BACKFILL
extPP1[] = Extrude {0,0,ELTh} {Surface{S_PP[]}; Layers{NLEL}; Recombine;};
// STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
V_PP[] = {V_PP[], extPP1[{1:#extPP1[]-1:6}]};

// UPDATE Surface LIST AT Y=prev.width+WSp
S_Yext[] = {S_Yext[], extPP1[ {4:(#extPP1[]-1):6} ]};

// UPDATE Surface LIST AT THE PARAPET 'ABUTMENTS'
S_abtpp[] = {S_abtpp[], extPP1[5], extPP1[#extPP1[]-3]};


// 2nd EXTRUSION FREE (NO CONTIGUOUS ELEMENTS TO PARAPET)
extPP2[] = Extrude {0,0,HPp-ELTh} {Surface{extPP1[{0:#extPP1[]-1:6}]}; Layers{NLPp}; Recombine;};
// STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
V_PP[] = {V_PP[], extPP2[{1:#extPP2[]-1:6}]};

// UPDATE Surface LIST AT Y=prev.width+WSp
S_Yext[] = {S_Yext[], extPP2[ {4:(#extPP2[]-1):6} ]};

// UPDATE Surface LIST AT THE PARAPET 'ABUTMENTS'
S_abtpp[] = {S_abtpp[], extPP2[5], extPP2[#extPP2[]-3]};
//------------------------------------------------------------------------------

Return
