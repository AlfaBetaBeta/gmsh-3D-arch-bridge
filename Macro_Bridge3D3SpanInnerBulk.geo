/************************************************************************************************************
 *
 *  Macro Bridge3D3SpanInnerBulk
 *
 *  Automated generation of the inner bulk (between spandrel walls) of the full 3D bridge segment of 3 spans, 
 *  including elastic ballast layer atop of the backfill
 *
 ************************************************************************************************************/
// MESH THE BRIDGE BULK IN BETWEEN SPANDREL WALLS VIA Y-EXTRUSIONS

// NOTES:	* XZ GEOMETRY AND LOADS DEFINED IN ANOTHER MACRO (Bridge2D3Span)
//		* ALL INPUT PARAMETERS NEEDED HERE ARE CARRIED ALONG FROM PREVIOUS MACROS 
//		* AS WITH Bridge2D3Span, THIS MACRO HANDLES ONLY SKEWBACKS AND BACKINGS OF 3 EDGES!

Macro Bridge3D3SpanInnerBulk

/*
IN:    		[WBf[]     = List of width values of the successive internal extrusions along Y]
       		[NLBf[]    = Number of layers along Wbf[] (in Y) upon discretisation]
	
		+ other args carried along from previous macros

INOUT:		S_Yext[]   = List of ALL Surfaces at Y=WBf[0]+...+WBf[#WBf[]-1]
		S_abtbk[]  = List of Surfaces at the backing 'abutments'
		S_base[]   = List of Surfaces at the pier bases
		S_abtarc[] = List of Surfaces at the arch 'abutments'
		S_abtbf[]  = List of Surfaces at the backfill 'abutments'
		S_load[]   = List of Surfaces forming the load strips

		V_BK[]     = List of Volumes forming the backings
		V_PR[]	   = List of Volumes forming the piers
		V_SK[]	   = List of ALL Volumes forming the skewbacks
		V_SK20[]   = List of WEDGE Volumes forming the skewbacks
		V_SK15[]   = List of HEXAHEDRAL Volumes forming the skewbacks
		V_AR[]	   = List of Volumes forming forming the arches
		V_BF[]	   = List of Volumes forming the backfill

		S_SK[] 	   = List with Surfaces forming the skewbacks (2D)]
		S_PR[] 	   = List with Surfaces forming the piers (2D)]
		S_AR[] 	   = List with Surfaces forming the arches (2D)]
		S_BK[] 	   = List with Surfaces forming the backing 'area' (2D)]
		S_BF[] 	   = List with Surfaces forming the backfill 'area' (2D)]

OUT:		extBK[]	   = List with all entities arising from extrusion of backings
		extPR[]	   = List with all entities arising from extrusion of piers
		extSK[]	   = List with all entities arising from extrusion of skewbacks
		extAR[]	   = List with all entities arising from extrusion of arches
		extBF[]	   = List with all entities arising from extrusion of backfill
	
		+ output from embedded macros
*/
//------------------------------------------------------------------------------
// AUX VARIABLES
auxar = 5+6*((TL1-1)*(TL3-1)-1);
auxar2 = (TL1-1)*(TL4-1);
auxar3 = (TL1-1)*((TL3-1)+(TL4-1)+(TL3-1));
auxar4 = (TL1-1)*(TL3-1);
//------------------------------------------------------------------------------
// EXTRUSIONS OF DIFFERENT BRIDGE 'AREAS' ALONG WBf[] IN SUCCESSIVE STAGES:
For jt In {0:#WBf[]-1}
//------------------------------------------------------------------------------
//	[1] BACKING
	extBK[] = Extrude {0,WBf[jt],0} { Surface{S_BK[]}; Layers{NLBf[jt]}; Recombine; };

//	STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST AND 
//	UPDATE Surface LIST AT Y=WBf[0]+...+WBf[jt]
	Call SurfaceVolumeRetrievalBacking;

//	UPDATE S_BK[] FOR FUTURE Y-EXTRUSIONS
	S_BK[] = {S_Yext[]};
//------------------------------------------------------------------------------
//	[2] PIERS
	extPR[] = Extrude {0,WBf[jt],0} { Surface{S_PR[]}; Layers{NLBf[jt]}; Recombine; };

//	STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
	V_PR[] = {V_PR[], extPR[{1:#extPR[]-1:6}]};

//	UPDATE Surface LIST AT Y=WBf[0]+...+WBf[jt]
	S_Yext[] = {S_Yext[], extPR[{0:#extPR[]-1:6}]};

//	UPDATE Surface LIST AT THE BASE OF THE PIERS
	S_base[] = {S_base[], extPR[{4:#extPR[]-1:6}]};

//	UPDATE S_PR[] FOR FUTURE Y-EXTRUSIONS
	S_PR[] = { extPR[{0:#extPR[]-1:6}] };
//------------------------------------------------------------------------------
//	[3] SKEWBACKS
	extSK[] = Extrude {0,WBf[jt],0} { Surface{S_SK[]}; Layers{NLBf[jt]}; Recombine; };

//	STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST AND
//	UPDATE Surface LIST AT Y=WBf[0]+...+WBf[jt]
	Call SurfaceVolumeRetrievalSkewback;

//	STORE THE SURFACES REPRESENTING CONTACT BACKING-SKEWBACK
	If (aux2sk != 0)
		S_bk2sk[] += { extSK[ {auxsp2sk1 : auxsp2sk1+6*(aux2sk-1) : 6*(TL1-1) } ] };
		S_bk2sk[] += { extSK[ {auxsp2sk2 : auxsp2sk2+6*(aux2sk-1) : 6*(TL1-1) } ] };
	EndIf

//	UPDATE S_SK[] FOR FUTURE Y-EXTRUSIONS
	S_SK[] = { S_Yext[{#S_Yext[]-(aux1*4+aux2sk*2) : #S_Yext[]-1}] };
//------------------------------------------------------------------------------
//	[4] ARCHES
	extAR[] = Extrude {0,WBf[jt],0} { Surface{S_AR[]}; Layers{NLBf[jt]}; Recombine; };

//	STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
	V_AR[] = {V_AR[], extAR[{1:#extAR[]-1:6}]};

//	UPDATE Surface LIST AT Y=WBf[0]+...+WBf[jt]
	S_Yext[] = {S_Yext[], extAR[{0:#extAR[]-1:6}]};

//	UPDATE Surface LIST AT THE ARCH 'ABUTMENTS'
	auxabtarc = 4+6*(TL1-1)*((TL3-2)+(TL4-1)+(TL3-1));
	S_abtarc[] = {S_abtarc[], extAR[{ auxabtarc : auxabtarc+6*(TL1-2) : 6 }]};
	auxabtarc2 = 3*auxabtarc+2*6*(TL1-2)+2*2;
	S_abtarc[] = {S_abtarc[], extAR[{ auxabtarc2 : auxabtarc2+6*(TL1-2) : 6}]};

//	STORE THE SURFACES REPRESENTING CONTACT BACKFILL-ARCHES
	S_bf2ar[] += { extAR[ {auxar+6 : auxar+6*auxar2 : 6*(TL1-1)} ] };
	S_bf2ar[] += { extAR[ {5+6*(auxar3+auxar4) : 5+6*(auxar3+auxar4-1)+6*auxar2 : 6*(TL1-1)} ] };
	S_bf2ar[] += { extAR[ {5+6*(2*auxar3+auxar4) : 5+6*(2*auxar3+auxar4-1)+6*auxar2 : 6*(TL1-1)} ] };
//	STORE THE SURFACES REPRESENTING CONTACT BACKING-ARCHES
	S_bk2ar[] += { extAR[ {5 : auxar : 6*(TL1-1)} ] };
	S_bk2ar[] += { extAR[ {auxar+6*(auxar2+1) : auxar+6*(auxar2+auxar4) : 6*(TL1-1)} ] };
	S_bk2ar[] += { extAR[ {5+6*auxar3 : 5+6*(auxar3+auxar4-1) : 6*(TL1-1)} ] };
	S_bk2ar[] += { extAR[ {5+6*(auxar3+auxar4+auxar2) : 5+6*(auxar3+2*auxar4+auxar2-1) : 6*(TL1-1)} ] };
	S_bk2ar[] += { extAR[ {5+6*(2*auxar3) : 5+6*(2*auxar3+auxar4-1) : 6*(TL1-1)} ] };
	S_bk2ar[] += { extAR[ {5+6*(2*auxar3+auxar4+auxar2) : 5+6*(2*auxar3+2*auxar4+auxar2-1) : 6*(TL1-1)} ] };

//	UPDATE S_AR[] FOR FUTURE Y-EXTRUSIONS
	S_AR[] = { extAR[{0:#extAR[]-1:6}] };
//------------------------------------------------------------------------------
//	[5] BACKFILL 'AREA' + ELASTIC LAYER
	extBF[] = Extrude {0,WBf[jt],0} { Surface{S_BF[]}; Layers{NLBf[jt]}; Recombine; };

//	STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
	V_BF[] = {V_BF[], extBF[1]};

//	UPDATE Surface LIST AT Y=WBf[0]+...+WBf[jt]
	S_Yext[] = {S_Yext[], extBF[0]};

//	ELASTIC LAYER ATOP OF THE BACKFILL
	extEL[] = Extrude {0,0,ELTh} { Surface{extBF[{2:2+2*#LdL[]}]}; Layers{NLEL}; Recombine;};
//	STORE THE VOLUMES GENERATED BY EXTRUSION IN A SEPARATE LIST
	V_EL[] = {V_EL[], extEL[{1 : #extEL[]-1 : 6}]};

//	UPDATE Surface LIST AT THE BACKFILL 'ABUTMENTS'
	S_abtbf[] = {S_abtbf[], extBF[#extBF[]-1]};
	S_abtbf[] = { S_abtbf[], extBF[2+#Lbf[]] };
//	ADD THE ELASTIC LAYER 'ABUTMENTS'
	S_abtbf[] = { S_abtbf[], extEL[5],extEL[#extEL[]-3] };

//	UPDATE Surface LIST WITH LOAD APPLICATION STRIPS
	If (LdBf[jt] != 0)
		For jload In {1:#LdL[]}
			S_load[] = {S_load[], extEL[6*(2*jload-1)]};
		EndFor
	EndIf

//	UPDATE S_BF[] FOR FUTURE Y-EXTRUSIONS
	S_BF[] = {extBF[0]};
//------------------------------------------------------------------------------
EndFor

Return
